Energy Optimization in Android Applications through Wakelock Placement Faisal Alam , Preeti Ranjan Panda , Nikhil Tripathi , Namita Sharma , and Sanjiv Narayan Indian Institute of Technology Delhi, New Delhi, India Calypto Design Systems (India) Pvt. Ltd., Noida, India Abstract Energy ef ciency is a critical factor in mobile systems, and a signi cant body of recent research efforts has focused on reducing the energy dissipation in mobile hardware and applica- tions. The Android OS Power Manager provides programming interface routines called wakelocks for controlling the activation state of devices on a mobile system. An appropriate placement of wakelock acquire and release functions in the application can make a signi cant difference to the energy consumption. In this paper, we propose a data ow analysis based strategy for determining the placement of wakelock statements corresponding to the uses of devices in an application. Our experimental evaluation on a set of Android applications show signi cant (up to 32%) energy savings with the proposed optimization strategy. I. INTRODUCTION Mobile systems are usually composed of several different devices with sophisticated functionality, whose ef cient energy management is key to achieving reasonable battery life. Care must be taken to ensure that the power and energy behavior of modern smartphones are in line with expectations. Smartphone users often experience applications executing in the back- ground more frequently than expected, keeping the devices awake for unexpectedly long durations. Frequent wake-ups, in turn, wake up other applications, leading to a cascading effect where unnecessary battery drain is caused by the power hungry resources such as WiFi and GPS. Mobile operating systems such as Android offer software power management through programming primitives called wakelocks that enable the acquiring and releasing of control over different system components. Wakelocks are useful when a task needs to be executed without interruption. If the applica- tion needs to prevent a device from being put to sleep because of long periods of inactivity, wakelocks are typically acquired at the start of a task execution and released on completion. However, inappropriate use of these APIs may lead to power being wasted in the devices, thereby affecting battery life. These situations are sometimes dif cult to trace because they do not affect the application functionality, but only lead to quicker battery discharge. In this paper, we propose a strategy that places the wakelock acquire and release function calls at appropriate positions in the application keeping energy ef ciency in view. The wake up time of different components is minimized during application execution, thereby reducing the overall energy consumption. II. RELATED WORK Early research in the eld of mobile phone energy optimization includes backlight brightness adjustment [8]. Pathak et al. [7] reported on issues related to energy ef ciency at various levels in the mobile systems such as rmware, application, and OS. Recent years have witnessed signi cant activity in this domain, and several tools have been developed to help application developers test their designs for energy ef ciency. Several optimizations have been proposed at the Dalvik Virtual Machine (DVM) level, which is the software responsible for the execution and management of applications in the Android platform [1], [2]. AccelDroid [3] attempts to improve byte code execution by reducing the two level translation process in a co- designed processor to one step, thereby achieving performance improvement and energy savings. At the application level, researchers have identi ed sources of energy loss resulting from wakelocks being acquired in Android Java applications without being released [4]. Mandatory wakelock releases were suggested to be placed in the try- nally Java blocks to rectify such situations. Jindal et al. [9] addressed sleep con icts that arise when the system is suspended with some components in high power state. None of the earlier works on energy optimization in mobile devices focuses on automatic code transformations that intel- ligently place wakelock acquire and release function calls. Works that detect possible sources of energy loss [4], [9] are the closest to our proposed technique. The programmer is expected to correct the inef ciencies manually. In contrast, our work advances the state-of-the-art by providing a strategy to minimize system power and energy by automatically de- termining the best placement of wakelock acquire and release statements. III. ILLUSTRATIVE EXAMPLES Figure 1a shows the ow graph of an illustrative example with four Basic Blocks, de ned as maximal sequence of instructions that can be entered at the rst statement and exited at the last. The wakelock for a device is acquired in BB0, and released after use in BB2. This may cause two sources of energy inef ciency. First, the wakelock is never released in path 0 1 3, leading to wasted energy when this path is traversed. Secondly, a signi cant amount of time lapses between the ACQUIRE and USE in path 0 2, leading to wasted energy because the device is ON but unused. The desirable placements of the ACQUIRE and RELEASE are indicated on the right, immediately before and after the USE. However, the placement of ACQUIRE/RELEASE adjacent to the USE might not be always best. Figure 1b shows a loop ( 1 2) in which the wakelock is acquired and released in every loop iteration, immediately before and after use. The ACQUIRE and RELEASE functions themselves lead 978-3-9815370-2-4/DATE14/ c 2014 EDAA (a) Bringing wakelock acquire/release closer to use (b) Reducing overhead of acquire/release Fig. 1: Wakelock placement impacts energy ef ciency to an energy overhead, and it is possible that this energy is larger than that incurred when the device is ON during typical instructions in the basic block. Hence, it may not be ef cient to release the device in one iteration, only to acquire it immediately in the next. A more ef cient solution could be to remove the ACQUIRE and RELEASE operations out of the loop, as illustrated on the right. The actual decision would depend on a quantitative comparison of the energy overhead of the wakelock ACQUIRE/RELEASE for the device, and the energy dissipated by the device during the intervening instructions in basic blocks BB2-BB1. In this paper, our contribution is to determine the energy-ef cient positions of the acquisition and release statements. IV. OPTIMIZATION STRATEGY We outline a Data Flow Analysis formulation for keeping track of the USEs of devices/resources, and deriving the best placements of the wakelock ACQUIRE and RELEASE statements in the code, with the objective of minimizing the energy wasted due to resources being unnecessarily kept active. A. Data Flow Analysis Consider a ow graph representing an application with basic blocks labeled , 1 . Assume we have devices/resources 1, ..., . The ow graph is augmented by dummy nodes ENTRY and EXIT representing the start and end of the function being analyzed. Each statement in the basic block may access zero or more resources, and we maintain an array USES[1.. , 1.. ], where USES[ , ] is set to TRUE if resource is accessed in . We assume that estimates are available for power consumption of resources when they are on, and the expected execution durations of each instruction. 1) Basic Block Level Analysis: We maintain two Boolean ar- rays WLIN[ , ] and WLOUT[ , ] to track the information about the need to acquire resources at the entrance and exit of each basic block. The arrays are initialized by a local analysis at the basic block level. Figure 2 shows a basic block consisting of statements [ , 1], ..., [ , ], with [ , ] ( [ , ]) being the rst (last) statement using in . We rst compute the energy estimates 1 and 2 , where 1 is the energy consumed by during the instructions before [ , ] ( [ , 1] to [ , 1]), and 2 is the energy consumed after [ , ] ( [ , + 1] to [ , ]). Let be the sum of energy overheads for acquiring and releasing resource . Clearly, if 1 > , then we can afford to turn off (release) before entering , and instead, acquire the resource immediately before its use at [ , ]. Similarly, if 2 > , we can release the resource right after its last use at [ , ], and acquire it in time for its next use after . This observation is captured by setting WLIN[ , ] and WLOUT[ , ] respectively to FALSE (or ). If WLIN[ , ] = , there is no need to acquire as we enter . Similarly, if WLOUT[ , ] = , there is no need to acquire as we exit . In both cases, the decision on acquire/release of can be taken locally, independent of other basic blocks. If these conditions are not true, we set the WLIN/WLOUT vaues to TRUE (or ), indicating that we MAY need to keep alive at the entrance/exit respectively of the basic block. This analysis is performed independently for all resources in all basic blocks. Fig. 2: Local data ow analysis within a Basic Block 2) Forward Propagation: The next step is to propagate the information in the individual basic blocks, beyond the basic block boundaries. Our problem has the characteristic of a bi- directional data ow analysis, since in an aggressive optimiza- tion, information needs to ow in both directions of the control ow graph from ENTRY to EXIT (on when to acquire), and from EXIT to ENTRY (on when to release). However, in practice, this bi-directional analysis can be split in our example into two simpler separate passes a forward propagation and a backward propagation. In the forward direction, we formulate the following data ow analysis equations to propagate the WLIN/WLOUT values. (a) (b) (c) (d) Fig. 3: Data Flow Analysis (a) Forward propagation from predecessors (b) Backward propagation from successors (c) Forward propagation within Basic Block (d) Backward prop- agation within Basic Block First, the WLIN/WLOUT values of the ENTRY node are initialized to FALSE for all since no resource needs to be acquired in the dummy node. WLIN[ENTRY, ] = WLOUT[ENTRY, ] = (1) A key de nition is the behavior of the JOIN node with multiple predecessors. Consider with predecessors and (Figure 3a). The value of WLIN[ , ] at the JOIN node is in uenced by the WLOUT values of its predecessors in the following way: WLIN[ , ] = WLIN[ , ] ( ) WLOUT[ , ] (2) Clearly, if WLIN[ , ] has already been established to be FALSE by a local basic block level analysis, then the decision stands irrespective of the behavior of any other basic block; therefore we use the AND operator with WLIN[ , ]. Similarly, if the WLOUT values of ALL predecessors of are FALSE (in our example, both WLOUT[ , ] and WLOUT[ , ] are FALSE), meaning that it is better to release at the exit of ALL predecessors of , then we can turn WLIN[ , ] also to FALSE. Even if is used in , we can acquire it inside the basic block, just before its use. In other cases, we can retain the original value for WLIN[ , ]. If is used in (USES[ , ] = TRUE), then the value of WLOUT[ , ] remains unchanged from the initial value. However, if there is no use of , we have an opportunity to propagate a FALSE value from WLIN[ , ] to WLOUT[ , ] if does not use , and the wakelock is released at its entry, then we have no need for it in the basic block, and can propagate this state to succeeding basic blocks (Figure 3c). The AND with WLOUT[ , ] follows the same logic as earlier if the wakelock for is not needed at s exit according to the local analysis, it will never be needed. WLOUT[ , ] = WLOUT[ , ] (WLIN[ , ] USES[ , ]) (3) 3) Backward Propagation: In the backward propagation step, the corresponding equations are (Figures 3b and 3d): WLIN[EXIT, ] = WLOUT[EXIT, ] = (4) WLOUT[ , ] = WLOUT[ , ] ( ) WLIN[ , ] (5) WLIN[ , ] = WLIN[ , ] (WLOUT[ , ] USES[ , ]) (6) As a pre-processing step, we replace a loop that does not access any of the resources, by a dummy basic block with an estimated energy dissipation for resource equal to the energy dissipation computed for the resource for the whole loop duration. Conditionals not accessing resources are also similarly simpli ed. B. Wakelock Placement Following the data ow analysis, the next step is to insert the wakelock ACQUIRE and RELEASE statements in the appropriate places in the code. Considering the individual basic blocks rst, if we have a USE of resource in , with WLIN[ , ] = FALSE, then we insert an ACQUIRE for just before the rst USE, since the wakelock won t be acquired at the basic block entry (Figure 4a). Similarly, a RELEASE is placed after the USE when WLOUT[ , ] = FALSE (Figure 4b). Crossing basic block boundaries, a wakelock ACQUIRE/RE- LEASE statement is necessary when we have an edge in the ow graph with a change in value for a resource. If the value changes from for a resource when following an edge (i.e., we have as a successor to , with WLOUT[ , ] = and WLIN[ , ] = ), we insert a wakelock RELEASE statement at the entry of (Figure 4c). To prevent releasing an already released resource (because of some other edge ending at ), the release statement can rst check if the resource is already acquired. The edge is similarly treated (Figure 4d). Fig. 4: Wakelock placement after Data Flow Analysis (a) False before USE (b) False after USE (c) T F Edge (d) F T Edge V. EXPERIMENTAL EVALUATION We conducted experiments to evaluate the effectiveness of our proposed power optimization strategy. We used PowerTutor [4], an application that estimates the energy consumption for Android applications, using a power model based on the HTC Dream phone. The application power simulation was performed on the GingerBread (2.3.4) Android version on a Samsung GT-S5670 phone (the host platform), which has a con guration similar to the target HTC phone, and would generate representative stimulus for the target. The total energy dissipation was compared between the unoptimized and opti- mized versions of the applications. The generated power data corresponds to the HTC target. We evaluated the effectiveness of our proposed optimization strategies on ve different open source applications [10]. The application characteristics and relevant optimizations are described below. The HttpMon application (Resources accessed: CPU, Display, Network Connection) is used for nding how long a website was up. It establishes contact with a given website at speci ed time intervals and noti es the user in case of an unsuccessful ping. The wakelock (PARTIAL WAKE LOCK) is acquired in the onReceive() function which keeps the CPU on for the duration it is acquired. It is acquired much before its actual use for the network connection and released only in the Finally block. In the optimized version, the wakelock acquire instruction was moved closer to the network connection use. In a second optimization, slack was introduced in the wakeup timing of an Alarm manager, leading to energy savings. The PocketTalk application (Resources accessed: CPU, Dis- play, Vibrator) reads aloud a text message received by the phone. It is also con gurable to encode each character into Morse code and communicate the message through vibrations. The wakelock (SCREEN DIM WAKE LOCK) controlling the CPU and display is acquired before converting the text to Morse code. If the phone s vibrator is off, leading to an exception, the wakelock is left acquired for a long duration. This is optimized by adding a try-catch block that releases the wakelock on encountering the exception. The Pedometer application (Resources accessed: CPU, Dis- play, Accelerometer) computes the number of steps a user has taken based on the number of shakes experienced by an accelerometer. Here, the wakelock (PARTIAL WAKE LOCK/ SCREEN DIM WAKE LOCK) is acquired (or released) when the start (or stop) button is pressed. This leads to unnecessary battery drainage as the wakelock is left acquired even when there is no accelerometer event. This is optimized to acquire and release the wakelock in the listener function for the shaking effect. The device now enters the high energy state only when a shake effect is experienced. The SalatTimes application (Resources accessed: CPU, Dis- play, GPS/WiFi, Alarm) sounds an alarm at the time of the Muslim prayer. It calculates the time of the prayer based on the device coordinates. The application starts the service for displaying the noti cation and sounding an alarm at the scheduled prayer time. However, after the noti cation, it does not stop the service, leading to unnecessary energy consumption. The optimized application acquires the wakelock (PARTIAL WAKE LOCK) at the service starting point and releases it soon after the noti cation and alarm instruction. The service is re-started and the wakelock is re-acquired when the Intent is next registered. Figure 5 gives a comparison of the energy consumption by the unoptimized and optimized versions of the applications, with the energy of the unoptimized application treated as 100%. The 100% corresponds to absolute values for the energy ranging from 80mJ to 458J. The applications were executed for durations ranging from 2 to 11 minutes in our experiments. We observe energy reductions between 8% and 32% as a result of applying the optimizations. Fig. 5: Optimization results for different Apps VI. CONCLUSIONS We addressed the issue of energy optimization in mobile applications by carefully controlling the placement of wake- lock statements that are responsible for the acquisition and release of devices. We outlined a data ow analysis formulation for determining the exact placement of wakelock statements corresponding to all the uses of devices in an application. Energy dissipation is reduced by ensuring that devices are maintained in active state only for the necessary duration. Our experiments on a set of applications indicate an overall energy reduction of up to 32% when the optimization is applied. Future research includes the investigation of a closer co-ordination between the application, compiler, and operating system on energy ef ciency issues. REFERENCES [1] C.-S. Wang, G. Perez, Y.-C. Chung, W.-C. Hsu, W.-K. Shih, and H.-R. Hsu, A Method-based Ahead-of-Time Compiler for Android Applications, CASES, 2011. [2] G. A. Perez, C.-M. Kao, Y.-C. Chung, and W.-C. Hsu, A hybrid just- in-time compiler for Android: comparing JIT types and the result of cooperation, CASES, 2012. [3] C. Wang, Y. Wu, and M. Cintra, Acceldroid: Co-designed acceleration of android bytecode, CGO, 2013. [4] A. Pathak, A. Jindal, Y. C. Hu, and S. P. Midkiff, What is keeping my phone awake?: Characterizing and detecting no-sleep energy bugs in smartphone apps, MobiSys, 2012. [5] L. Zhang, B. Tiwana, Z. Qian, Z. Wang, R. P. Dick, Z. M. Mao, and L. Yang, Accurate online power estimation and automatic battery be- havior based power model generation for smartphones, CODES+ISSS, 2010. [6] A. Pathak, Y. C. Hu, and M. Zhang, Where is the energy spent inside my app?: ne grained energy accounting on smartphones with Eprof, EuroSys, 2012 [7] A. Pathak, Y. C. Hu, and M. Zhang, Bootstrapping energy debugging on smartphones: a rst look at energy bugs in mobile devices , HotNets, 2011. [8] R. Cornea, A. Nicolau, and N. Dutt, Software Annotations for Power Optimization on Mobile Devices , DATE, 2006. [9] A. Jindal, A. Pathak, Y. C. Hu, and S. P. Midkiff, Hypnos: understand- ing and treating sleep con icts in smartphones , Eurosys, 2013. [10] Google Play, http://play.google.com